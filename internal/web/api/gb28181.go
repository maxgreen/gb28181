// Code generated by gowebx, DO AVOID EDIT.
package api

import (
	"fmt"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gowvp/gb28181/internal/core/bz"
	"github.com/gowvp/gb28181/internal/core/gb28181"
	"github.com/gowvp/gb28181/internal/core/media"
	"github.com/gowvp/gb28181/internal/core/sms"
	"github.com/gowvp/gb28181/internal/core/uniqueid"
	"github.com/gowvp/gb28181/pkg/gbs"
	"github.com/gowvp/gb28181/pkg/zlm"
	"github.com/ixugo/goweb/pkg/web"
)

type GB28181API struct {
	gb28181Core gb28181.Core
	uc          *Usecase
}

func NewGB28181API(core gb28181.Core) GB28181API {
	return GB28181API{gb28181Core: core}
}

func NewGB28181Core(store gb28181.Storer, uni uniqueid.Core) gb28181.Core {
	return gb28181.NewCore(store, uni)
}

func registerGB28181(g gin.IRouter, api GB28181API, handler ...gin.HandlerFunc) {
	{
		group := g.Group("/devices", handler...)
		group.GET("", web.WarpH(api.findDevice))
		group.GET("/:id", web.WarpH(api.getDevice))
		group.PUT("/:id", web.WarpH(api.editDevice))
		group.POST("", web.WarpH(api.addDevice))
		group.DELETE("/:id", web.WarpH(api.delDevice))

		group.POST("/:id/catalog", web.WarpH(api.queryCatalog)) // 刷新通道
	}

	{
		group := g.Group("/channels", handler...)
		group.GET("", web.WarpH(api.findChannel))
		group.PUT("/:id", web.WarpH(api.editChannel))
		group.POST("/:id/play", web.WarpH(api.play))
		// group.GET("/:id", web.WarpH(api.getChannel))
		// group.POST("", web.WarpH(api.addChannel))
		// group.DELETE("/:id", web.WarpH(api.delChannel))
	}
}

// >>> device >>>>>>>>>>>>>>>>>>>>

func (a GB28181API) findDevice(c *gin.Context, in *gb28181.FindDeviceInput) (any, error) {
	items, total, err := a.gb28181Core.FindDevice(c.Request.Context(), in)
	return gin.H{"items": items, "total": total}, err
}

func (a GB28181API) getDevice(c *gin.Context, _ *struct{}) (any, error) {
	deviceID := c.Param("id")
	return a.gb28181Core.GetDevice(c.Request.Context(), deviceID)
}

func (a GB28181API) editDevice(c *gin.Context, in *gb28181.EditDeviceInput) (any, error) {
	deviceID := c.Param("id")
	return a.gb28181Core.EditDevice(c.Request.Context(), in, deviceID)
}

func (a GB28181API) addDevice(c *gin.Context, in *gb28181.AddDeviceInput) (any, error) {
	return a.gb28181Core.AddDevice(c.Request.Context(), in)
}

func (a GB28181API) delDevice(c *gin.Context, _ *struct{}) (any, error) {
	did := c.Param("id")
	return a.gb28181Core.DelDevice(c.Request.Context(), did)
}

func (a GB28181API) queryCatalog(c *gin.Context, _ *struct{}) (any, error) {
	did := c.Param("id")
	if err := a.uc.SipServer.QueryCatalog(did); err != nil {
		return nil, web.ErrDevice.Msg(err.Error())
	}
	return gin.H{"msg": "ok"}, nil
}

// >>> channel >>>>>>>>>>>>>>>>>>>>

func (a GB28181API) findChannel(c *gin.Context, in *gb28181.FindChannelInput) (any, error) {
	items, total, err := a.gb28181Core.FindChannel(c.Request.Context(), in)
	return gin.H{"items": items, "total": total}, err
}

// func (a GB28181API) getChannel(c *gin.Context, _ *struct{}) (any, error) {
// 	channelID := c.Param("id")
// 	return a.gb28181Core.GetChannel(c.Request.Context(), channelID)
// }

func (a GB28181API) editChannel(c *gin.Context, in *gb28181.EditChannelInput) (any, error) {
	cid := c.Param("id")
	return a.gb28181Core.EditChannel(c.Request.Context(), in, cid)
}

// func (a GB28181API) addChannel(c *gin.Context, in *gb28181.AddChannelInput) (any, error) {
// 	return a.gb28181Core.AddChannel(c.Request.Context(), in)
// }

// func (a GB28181API) delChannel(c *gin.Context, _ *struct{}) (any, error) {
// 	channelID := c.Param("id")
// 	return a.gb28181Core.DelChannel(c.Request.Context(), channelID)
// }

func (a GB28181API) play(c *gin.Context, _ *struct{}) (*playOutput, error) {
	channelID := c.Param("id")

	var app, appStream, host, stream, session string
	var svr *sms.MediaServer

	// 国标逻辑
	if strings.HasPrefix(channelID, bz.IDPrefixGBChannel) {
		// a.uc.SipServer.
		ch, err := a.gb28181Core.GetChannel(c.Request.Context(), channelID)
		if err != nil {
			return nil, err
		}

		app = "rtp"
		appStream = ch.ID

		svr, err = a.uc.SMSAPI.smsCore.GetMediaServer(c.Request.Context(), sms.DefaultMediaServerID)
		if err != nil {
			return nil, err
		}

		dev, err := a.gb28181Core.GetDeviceByDeviceID(c.Request.Context(), ch.DeviceID)
		if err != nil {
			return nil, err
		}

		if err := a.uc.SipServer.Play(&gbs.PlayInput{
			Channel:    ch,
			StreamMode: dev.StreamMode,
			SMS:        svr,
		}); err != nil {
			return nil, web.ErrDevice.Msg(err.Error())
		}
	} else if strings.HasPrefix(channelID, bz.IDPrefixRTMP) {
		push, err := a.uc.MediaAPI.mediaCore.GetStreamPush(c.Request.Context(), channelID)
		if err != nil {
			return nil, err
		}
		if push.Status != media.StatusPushing {
			return nil, web.ErrNotFound.Msg("未推流")
		}
		app = push.App
		appStream = push.Stream

		svr, err = a.uc.SMSAPI.smsCore.GetMediaServer(c.Request.Context(), push.MediaServerID)
		if err != nil {
			return nil, err
		}

		if !push.IsAuthDisabled && push.Session != "" {
			session = "session=" + push.Session
		}
	} else if strings.HasPrefix(channelID, bz.IDPrefixRTSP) {
		proxy, err := a.uc.ProxyAPI.proxyCore.GetStreamProxy(c.Request.Context(), channelID)
		if err != nil {
			return nil, err
		}
		app = proxy.App
		appStream = proxy.Stream

		svr, err = a.uc.SMSAPI.smsCore.GetMediaServer(c.Request.Context(), sms.DefaultMediaServerID)
		if err != nil {
			return nil, err
		}
		resp, err := a.uc.SMSAPI.smsCore.AddStreamProxy(svr, zlm.AddStreamProxyRequest{
			Vhost:      "__defaultVhost__",
			App:        proxy.App,
			Stream:     proxy.Stream,
			URL:        proxy.SourceURL,
			RetryCount: 3,
			RTPType:    proxy.Transport,
			TimeoutSec: 10,
			// EnableRTMP:   zlm.NewBool(true),
			// EnableRTSP:   zlm.NewBool(true),
			// EnableHLS:    zlm.NewBool(true),
			// EnableAudio:  zlm.NewBool(true),
			AddMuteAudio: zlm.NewBool(true),
			// AutoClose:    zlm.NewBool(false),
		})
		if err != nil {
			return nil, web.ErrServer.Msg(err.Error())
		}
		a.uc.ProxyAPI.proxyCore.EditStreamProxyKey(c.Request.Context(), resp.Data.Key, proxy.ID)
	} else {
		return nil, web.ErrNotFound.Msg("不支持的播放通道")
	}
	stream = app + "/" + appStream

	host = c.Request.Host
	if l := strings.Split(c.Request.Host, ":"); len(l) == 2 {
		host = l[0]
	}

	// 播放规则
	// https://github.com/zlmediakit/ZLMediaKit/wiki/%E6%92%AD%E6%94%BEurl%E8%A7%84%E5%88%99
	return &playOutput{
		App:    app,
		Stream: appStream,
		Items: []streamAddrItem{
			{
				Label:   "默认线路",
				WSFLV:   fmt.Sprintf("ws://%s:%d/%s.live.flv", host, svr.Ports.HTTP, stream) + "?" + session,
				HTTPFLV: fmt.Sprintf("http://%s:%d/%s.live.flv", host, svr.Ports.HTTP, stream) + "?" + session,
				RTMP:    fmt.Sprintf("rtmp://%s:%d/%s", host, svr.Ports.RTMP, stream) + "?" + session,
				RTSP:    fmt.Sprintf("rtsp://%s:%d/%s", host, svr.Ports.RTSP, stream) + "?" + session,
				WebRTC:  fmt.Sprintf("webrtc://%s:%d/index/api/webrtc?app=%s&stream=%s&type=play", host, svr.Ports.HTTP, app, stream) + "&" + session,
				HLS:     fmt.Sprintf("http://%s:%d/%s/hls.fmp4.m3u8", host, svr.Ports.HTTP, stream) + "?" + session,
			},
			{
				Label:   "SSL 线路",
				WSFLV:   fmt.Sprintf("wss://%s:%d/%s.live.flv", host, svr.Ports.HTTP, stream) + session,
				HTTPFLV: fmt.Sprintf("https://%s:%d/%s.live.flv", host, svr.Ports.HTTP, stream) + session,
				RTMP:    fmt.Sprintf("rtmps://%s:%d/%s", host, svr.Ports.RTMPs, stream) + session,
				RTSP:    fmt.Sprintf("rtsps://%s:%d/%s", host, svr.Ports.RTSPs, stream) + session,
				WebRTC:  fmt.Sprintf("webrtc://%s:%d/index/api/webrtc?app=%s&stream=%s&type=play", host, svr.Ports.HTTPS, app, stream) + "&" + session,
				HLS:     fmt.Sprintf("https://%s:%d/%s/hls.fmp4.m3u8", host, svr.Ports.HTTPS, stream) + "?" + session,
			},
		},
	}, nil
}

func (uc *Usecase) play(channelID string) {
}
